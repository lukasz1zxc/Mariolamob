<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Mariola – grafika z /img</title>
  <style>
    :root{ --bg:#86c9ff; --bg2:#cfeaff; }
    html,body{margin:0;height:100%;font-family:system-ui,Segoe UI,Arial,sans-serif;background:var(--bg)}
    #wrap{display:flex;align-items:center;justify-content:center;height:100%}
    canvas{background:linear-gradient(var(--bg), var(--bg2)); width:100%; max-width:1080px; aspect-ratio:16/9; border-radius:14px; box-shadow:0 14px 40px rgba(0,0,0,.25); image-rendering: pixelated;}
    .hud{position:fixed;left:50%;top:8px;transform:translateX(-50%);background:rgba(0,0,0,.55);color:#fff;padding:8px 12px;border-radius:10px;font-weight:700;display:flex;gap:10px}
    .help{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.35);color:#fff;padding:6px 10px;border-radius:8px;font-size:12px}
    .btn{position:fixed;right:10px;top:10px;background:#fff;border:1px solid #ddd;border-radius:10px;padding:8px 10px;cursor:pointer}
  </style>
</head>
<body>
  <div class="hud" id="hud">Ładowanie…</div>
  <button class="btn" id="resetBtn">Restart</button>
  <div id="wrap"><canvas id="game" width="1280" height="720"></canvas></div>
  <div class="help">Sterowanie: ←/→ ruch • ↑/Spacja skok • X/Shift dash • P pauza</div>

<script>
(() => {
  /* ==========================================================
     0) KONFIGURACJA SPRITE'ÓW – dostosuj do swoich plików w /img
     Każdy arkusz ma zdefiniowane: src, frameWidth, frameHeight, cols, rows
     oraz proste animacje z listą indeksów klatek.
     Indeks liczymy wierszami: 0..cols-1, potem kolejny wiersz.
  ========================================================== */
  const SPRITE_CFG = {
    hero:      { src:'img/hero.png',      fw:32, fh:32, cols:10, rows:1, anim:{ idle:[0,1], run:[2,3,4,5], jump:[6], attack:[7,8], fall:[9] }, fps:10 },
    bat:       { src:'img/bat.png',       fw:32, fh:32, cols:3, rows:1,  anim:{ fly:[0,1,2] }, fps:8 },
    bird:      { src:'img/bird.png',      fw:32, fh:32, cols:2, rows:1,  anim:{ fly:[0,1] }, fps:8 },
    turtle:    { src:'img/turtle.png',    fw:32, fh:32, cols:2, rows:1,  anim:{ walk:[0,1] }, fps:6 },
    golem:     { src:'img/golem.png',     fw:32, fh:32, cols:3, rows:1,  anim:{ walk:[0,1,2] }, fps:6 },
    demon:     { src:'img/demon.png',     fw:64, fh:64, cols:2, rows:2,  anim:{ idle:[0,1,2,3] }, fps:6 },
    coin:      { src:'img/coin.png',      fw:16, fh:16, cols:4, rows:1,  anim:{ spin:[0,1,2,3] }, fps:8 },
    hourglass: { src:'img/hourglass.png', fw:16, fh:16, cols:3, rows:1,  anim:{ glow:[0,1,2] }, fps:6 },
    dust:      { src:'img/dust.png',      fw:32, fh:32, cols:3, rows:1,  anim:{ puff:[0,1,2] }, fps:14 },
    tileset:   { src:'img/tileset.png',   fw:16, fh:16, cols:8, rows:8 },
    bgFar:     { src:'img/Background_far.png' },
    bgMid:     { src:'img/Background_mid.png' },
  };

  /* ==========================================================
     1) ŁADOWANIE ZASOBÓW
  ========================================================== */
  const loadImage = (src)=> new Promise((res,rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=src; });
  async function loadAssets(){
    const entries = Object.entries(SPRITE_CFG);
    const imgs = await Promise.all(entries.map(([k,c])=> loadImage(c.src).then(img=>[k,img])));
    const assets = Object.fromEntries(imgs);
    return assets;
  }

  /* ==========================================================
     2) POMOCNICZE: SpriteSheet + prosta animacja
  ========================================================== */
  class SpriteSheet{
    constructor(img, fw, fh, cols, rows){ this.img=img; this.fw=fw; this.fh=fh; this.cols=cols; this.rows=rows; }
    draw(ctx, dx, dy, frame, flip=false, scale=1){
      const sx = (frame % this.cols) * this.fw;
      const sy = Math.floor(frame / this.cols) * this.fh;
      ctx.save();
      ctx.translate(dx, dy);
      if(flip){ ctx.scale(-1,1); dx=0; }
      ctx.imageSmoothingEnabled=false;
      ctx.drawImage(this.img, sx, sy, this.fw, this.fh, flip? -this.fw*scale : 0, 0, this.fw*scale, this.fh*scale);
      ctx.restore();
    }
  }
  class Animator{
    constructor(frames, fps){ this.frames=frames; this.fps=fps; this.t=0; }
    step(dt){ this.t += dt * this.fps; }
    frame(){ if(!this.frames||this.frames.length===0) return 0; return this.frames[Math.floor(this.t)%this.frames.length]; }
    reset(){ this.t=0; }
  }

  /* ==========================================================
     3) GRA – fizyka jak wcześniej, ale rysowanie sprite'ami
  ========================================================== */
  const TILE=48, G=2000, JUMP=820, FRICTION=0.86, MAX_VX=320;
  const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d');
  const hud=document.getElementById('hud'); const resetBtn=document.getElementById('resetBtn');

  // Przykładowe levele jak wcześniej
  const levels=[
`................................................................................
................................................................................
...............................................?...............................
..............................?.................................................
......................###......................................................
.............?.........................E........................................
....P....#########.............###.....................?????.................F..
......................###..............#####..........#########................
.............###............................................................###
.............................................######.....................#######
########################.....############..###########....#####################
########################.....############..###########....#####################`
  ];

  // Zmienne globalne
  let keys={}, camX=0, paused=false; let assets, SS={};

  function aabb(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }

  class Rect{ constructor(x,y,w,h){ this.x=x; this.y=y; this.w=w; this.h=h; } }

  class Camera{ follow(p){ const m=canvas.width*0.35; const cx=camX+canvas.width*0.5; if(p.x-cx>m) camX=p.x-m-canvas.width*0.5; if(cx-p.x>m) camX=p.x+m-canvas.width*0.5; camX=Math.max(0, Math.min(camX, level.pixelW-canvas.width)); } }

  class Player extends Rect{
    constructor(x,y){ super(x,y,32*2,32*2); this.vx=0; this.vy=0; this.on=false; this.flip=false; this.anim=new Animator(SPRITE_CFG.hero.anim.run, SPRITE_CFG.hero.fps); this.state='run'; this.lives=3; this.score=0; }
    setState(s){ if(this.state!==s){ this.state=s; this.anim=new Animator(SPRITE_CFG.hero.anim[s]||[0], SPRITE_CFG.hero.fps); } }
    update(dt){
      const dir=(keys.ArrowRight||keys.KeyD?1:0) - (keys.ArrowLeft||keys.KeyA?1:0);
      if(dir!==0){ this.vx+=dir*2600*dt; this.vx=Math.max(-MAX_VX, Math.min(MAX_VX,this.vx)); this.flip = dir<0; this.setState('run'); }
      else { this.vx*=FRICTION; if(Math.abs(this.vx)<4) this.vx=0; this.setState('idle'); }
      this.vy+=G*dt;
      if((keys.Space||keys.ArrowUp||keys.KeyW) && this.on){ this.vy=-JUMP; this.on=false; this.setState('jump'); }
      // ruch X
      this.x+=this.vx*dt; for(const t of level.query(this)){ if(!t.s) continue; if(aabb(this,t)){ if(this.vx>0) this.x=t.x-this.w; else this.x=t.x+t.w; this.vx=0; }}
      // ruch Y
      this.y+=this.vy*dt; this.on=false; for(const t of level.query(this)){ if(!t.s) continue; if(aabb(this,t)){ if(this.vy>0){ this.y=t.y-this.h; this.vy=0; this.on=true; } else { this.y=t.y+t.h; this.vy=0; } }}
      // kolizje z monetami i wrogiem
      for(const c of level.coins){ if(!c.hit && aabb(this,c)){ c.hit=true; this.score+=10; }}
      for(const e of level.enemies){ if(e.dead) continue; if(aabb(this,e)){ if(this.vy>160){ e.dead=true; this.vy=-JUMP*0.7; this.score+=25; } else { this.lives=Math.max(0,this.lives-1); this.x=level.spawn.x; this.y=level.spawn.y; } }}
      if(level.flag && aabb(this, level.flag)) nextLevel();
      this.anim.step(dt);
    }
    draw(){ SS.hero.draw(ctx, this.x-camX, this.y, this.anim.frame(), this.flip, 2); }
  }

  class Enemy extends Rect{
    constructor(x,y,type){ super(x,y,32*2,32*2); this.type=type; this.vx= type==='bat'? 80 : 60; if(type==='bat'||type==='bird') this.vx*= (Math.random()<0.5?-1:1); this.vy=0; this.dead=false; this.flip=false; this.anim=new Animator((SPRITE_CFG[type].anim.fly||SPRITE_CFG[type].anim.walk), SPRITE_CFG[type].fps); }
    update(dt){ if(this.dead) return; this.vy += G*dt; this.x += this.vx*dt; this.y += this.vy*dt; this.flip = this.vx<0;
      for(const t of level.query(this)) if(t.s && aabb(this,t)){ if(this.vy>0 && this.y+this.h-t.y<24){ this.y=t.y-this.h; this.vy=0; } else { this.vx*=-1; if(this.vx>0) this.x=t.x-this.w; else this.x=t.x+t.w; } }
      this.anim.step(dt);
    }
    draw(){ SS[this.type].draw(ctx, this.x-camX, this.y, this.anim.frame(), this.flip, 2); }
  }

  class Coin extends Rect{ constructor(x,y){ super(x,y,16*2,16*2); this.hit=false; this.anim=new Animator(SPRITE_CFG.coin.anim.spin, SPRITE_CFG.coin.fps);} update(dt){ this.anim.step(dt);} draw(){ SS.coin.draw(ctx, this.x-camX, this.y, this.anim.frame(), false, 2);} }

  class PowerUp extends Rect{ constructor(x,y){ super(x,y,16*2,16*2); this.anim=new Animator(SPRITE_CFG.hourglass.anim.glow, SPRITE_CFG.hourglass.fps);} update(dt){ this.anim.step(dt);} draw(){ SS.hourglass.draw(ctx, this.x-camX, this.y, this.anim.frame(), false, 2);} }

  class Level{
    constructor(plan){ this.rows=plan.trim().split('\n'); this.h=this.rows.length; this.w=this.rows[0].length; this.pixelW=this.w*TILE; this.pixelH=this.h*TILE; this.spawn={x:0,y:0}; this.flag=null; this.blocks=[]; this.coins=[]; this.enemies=[]; this.powers=[];
      for(let y=0;y<this.h;y++) for(let x=0;x<this.w;x++){ const ch=this.rows[y][x]; const px=x*TILE, py=y*TILE; if(ch=='#') this.blocks.push(new Rect(px,py,TILE,TILE)); if(ch=='?') this.coins.push(new Coin(px+TILE*0.3, py+TILE*0.3)); if(ch=='E') this.enemies.push(new Enemy(px, py, ['bat','bird','turtle','golem'][Math.floor(Math.random()*4)])); if(ch=='F') this.flag=new Rect(px+TILE*0.2, py-TILE*0.5, TILE*0.6, TILE*1.5); if(ch=='P') this.spawn={x:px+TILE*0.1, y:py-TILE*0.2}; }
    }
    query(r){ const res=[]; const x0=Math.max(0,Math.floor(r.x/TILE)-1), x1=Math.min(this.w-1,Math.floor((r.x+r.w)/TILE)+1); const y0=Math.max(0,Math.floor(r.y/TILE)-1), y1=Math.min(this.h-1,Math.floor((r.y+r.h)/TILE)+1); for(let y=y0;y<=y1;y++) for(let x=x0;x<=x1;x++){ if(this.rows[y][x]==='#') res.push({x:x*TILE,y:y*TILE,w:TILE,h:TILE,s:true}); } return res; }
    drawBackground(){ // parallax tła
      const far=assets.bgFar, mid=assets.bgMid; const h=canvas.height; const w=canvas.width;
      if(far){ const speed=0.2; const ox=-(camX*speed)%far.width; for(let x=ox-w; x<w; x+=far.width) ctx.drawImage(far, x, 0, far.width, h*0.6); }
      if(mid){ const speed=0.4; const ox=-(camX*speed)%mid.width; for(let x=ox-w; x<w; x+=mid.width) ctx.drawImage(mid, x, h*0.15, mid.width, h*0.7); }
    }
    drawTiles(){ if(!assets.tileset) { // fallback prostokąty
        ctx.fillStyle='#8b572a'; for(const b of this.blocks){ const sx=b.x-camX, sy=b.y; if(sx<-TILE||sx>canvas.width||sy<-TILE||sy>canvas.height) continue; ctx.fillRect(sx,sy,TILE,TILE); }
        return; }
      const tsImg=assets.tileset; const S=new SpriteSheet(tsImg, SPRITE_CFG.tileset.fw, SPRITE_CFG.tileset.fh, SPRITE_CFG.tileset.cols, SPRITE_CFG.tileset.rows);
      const scale=TILE/SPRITE_CFG.tileset.fw;
      for(let i=0;i<this.blocks.length;i++){
        const b=this.blocks[i]; const sx=b.x-camX, sy=b.y; if(sx<-TILE||sx>canvas.width||sy<-TILE||sy>canvas.height) continue;
        // prosto: dirt (index 0) + jeśli nad pustką – grass top (index 1)
        S.draw(ctx, sx, sy, 0, false, scale);
        const gx=Math.floor(b.x/TILE), gy=Math.floor(b.y/TILE)-1; const above = gy>=0 ? (this.rows[gy][gx]==='#') : false;
        if(!above) S.draw(ctx, sx, sy, 1, false, scale);
      }
    }
    drawObjects(dt){ for(const c of this.coins){ c.update(dt); c.draw(); } for(const p of this.powers){ p.update(dt); p.draw(); } for(const e of this.enemies){ e.update(dt); e.draw(); } }
    drawFlag(){ if(!this.flag) return; ctx.fillStyle='#2ecc71'; ctx.fillRect(this.flag.x-camX+this.flag.w-6, this.flag.y, 6, this.flag.h); ctx.beginPath(); ctx.moveTo(this.flag.x-camX, this.flag.y+12); ctx.lineTo(this.flag.x-camX+this.flag.w, this.flag.y+24); ctx.lineTo(this.flag.x-camX, this.flag.y+36); ctx.closePath(); ctx.fill(); }
  }

  let level, player, cam;

  function start(){ level=new Level(levels[0]); player=new Player(level.spawn.x, level.spawn.y); cam=new Camera(); }

  function nextLevel(){ /* tu ewentualna obsługa kolejnych map */ }

  // Pętla
  let last=performance.now();
  function loop(ts){ const dt=Math.min(0.033, (ts-last)/1000); last=ts; if(paused){ requestAnimationFrame(loop); return; }
    player.update(dt); cam.follow(player);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    level.drawBackground();
    level.drawTiles();
    level.drawFlag();
    level.drawObjects(dt);
    player.draw();
    hud.textContent = `Punkty: ${player.score} | Życia: ${player.lives}`;
    requestAnimationFrame(loop);
  }

  // Wejście
  window.addEventListener('keydown', e=>{ keys[e.code]=true; if(e.code==='KeyP') paused=!paused; });
  window.addEventListener('keyup', e=>{ keys[e.code]=false; });
  resetBtn.addEventListener('click', ()=>{ start(); });

  // Start po załadowaniu obrazów
  loadAssets().then(a=>{
    assets=a;
    // Utwórz obiekty SpriteSheet na podstawie załadowanych obrazów
    SS.hero      = new SpriteSheet(assets.hero,      SPRITE_CFG.hero.fw,      SPRITE_CFG.hero.fh,      SPRITE_CFG.hero.cols,      SPRITE_CFG.hero.rows);
    SS.bat       = new SpriteSheet(assets.bat,       SPRITE_CFG.bat.fw,       SPRITE_CFG.bat.fh,       SPRITE_CFG.bat.cols,       SPRITE_CFG.bat.rows);
    SS.bird      = new SpriteSheet(assets.bird,      SPRITE_CFG.bird.fw,      SPRITE_CFG.bird.fh,      SPRITE_CFG.bird.cols,      SPRITE_CFG.bird.rows);
    SS.turtle    = new SpriteSheet(assets.turtle,    SPRITE_CFG.turtle.fw,    SPRITE_CFG.turtle.fh,    SPRITE_CFG.turtle.cols,    SPRITE_CFG.turtle.rows);
    SS.golem     = new SpriteSheet(assets.golem,     SPRITE_CFG.golem.fw,     SPRITE_CFG.golem.fh,     SPRITE_CFG.golem.cols,     SPRITE_CFG.golem.rows);
    SS.demon     = new SpriteSheet(assets.demon,     SPRITE_CFG.demon.fw,     SPRITE_CFG.demon.fh,     SPRITE_CFG.demon.cols,     SPRITE_CFG.demon.rows);
    SS.coin      = new SpriteSheet(assets.coin,      SPRITE_CFG.coin.fw,      SPRITE_CFG.coin.fh,      SPRITE_CFG.coin.cols,      SPRITE_CFG.coin.rows);
    SS.hourglass = new SpriteSheet(assets.hourglass, SPRITE_CFG.hourglass.fw, SPRITE_CFG.hourglass.fh, SPRITE_CFG.hourglass.cols, SPRITE_CFG.hourglass.rows);
    SS.dust      = new SpriteSheet(assets.dust,      SPRITE_CFG.dust.fw,      SPRITE_CFG.dust.fh,      SPRITE_CFG.dust.cols,      SPRITE_CFG.dust.rows);
    SS.tileset   = new SpriteSheet(assets.tileset,   SPRITE_CFG.tileset.fw,   SPRITE_CFG.tileset.fh,   SPRITE_CFG.tileset.cols,   SPRITE_CFG.tileset.rows);

    start();
    requestAnimationFrame(loop);
  }).catch(err=>{
    hud.textContent = 'Błąd ładowania grafik (sprawdź ścieżki w SPRITE_CFG).';
    console.error(err);
  });
})();
</script>
</body>
</html>
