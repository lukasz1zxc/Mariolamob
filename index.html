<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Mariola – sprite fix</title>
  <style>
    :root{ --bg:#86c9ff; --bg2:#cfeaff; }
    html,body{margin:0;height:100%;font-family:system-ui,Segoe UI,Arial,sans-serif;background:var(--bg)}
    #wrap{display:flex;align-items:center;justify-content:center;height:100%}
    canvas{background:linear-gradient(var(--bg), var(--bg2)); width:100%; max-width:1080px; aspect-ratio:16/9; border-radius:14px; box-shadow:0 14px 40px rgba(0,0,0,.25); image-rendering: pixelated;}
    .hud{position:fixed;left:50%;top:8px;transform:translateX(-50%);background:rgba(0,0,0,.55);color:#fff;padding:8px 12px;border-radius:10px;font-weight:700;display:flex;gap:10px}
    .help{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.35);color:#fff;padding:6px 10px;border-radius:8px;font-size:12px}
    .btn{position:fixed;right:10px;top:10px;background:#fff;border:1px solid #ddd;border-radius:10px;padding:8px 10px;cursor:pointer}
  </style>
</head>
<body>
  <div class="hud" id="hud">Ładowanie…</div>
  <button class="btn" id="resetBtn">Restart</button>
  <div id="wrap"><canvas id="game" width="1280" height="720"></canvas></div>
  <div class="help">Sterowanie: ←/→ ruch • ↑/Spacja skok • P pauza</div>

<script>
(() => {
  /* ==========================================================
     0) KONFIG – układy klatek z Twoich plików
     (fw/fh liczymy automatycznie z wymiarów obrazka)
  ========================================================== */
  const SPRITE_CFG = {
    hero:      { src:'img/hero.png',      cols:4, rows:2, anim:{ idle:[0,1], run:[2,3], jump:[4], fall:[5], attack:[6,7] }, fps:10 },
    bat:       { src:'img/bat.png',       cols:3, rows:1, anim:{ fly:[0,1,2] }, fps:8 },
    bird:      { src:'img/bird.png',      cols:2, rows:1, anim:{ fly:[0,1] }, fps:8 },
    turtle:    { src:'img/turtle.png',    cols:2, rows:1, anim:{ walk:[0,1] }, fps:6 },
    golem:     { src:'img/golem.png',     cols:3, rows:1, anim:{ walk:[0,1,2] }, fps:6 },
    demon:     { src:'img/demon.png',     cols:2, rows:2, anim:{ idle:[0,1,2,3] }, fps:6 },
    coin:      { src:'img/coin.png',      cols:4, rows:1, anim:{ spin:[0,1,2,3] }, fps:10 },
    hourglass: { src:'img/hourglass.png', cols:3, rows:1, anim:{ glow:[0,1,2] }, fps:8 },
    dust:      { src:'img/dust.png',      cols:3, rows:1, anim:{ puff:[0,1,2] }, fps:14 },
    tileset:   { src:'img/tileset.png',   cols:1, rows:1 }, // nieregularny arkusz – użyjemy fallbacku
    bgFar:     { src:'img/background_far.png' },
    bgMid:     { src:'img/background_mid.png' },
  };

  // Włącz, jeśli chcesz usuwać „szachownicę” (jasnoszare tło) z obrazów.
  const AUTO_TRANSPARENT = true;

  const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d');
  const hud=document.getElementById('hud'); const resetBtn=document.getElementById('resetBtn');

  /* ==========================================================
     1) Narzędzia
  ========================================================== */
  const loadImage = (src)=> new Promise((res,rej)=>{ const i=new Image(); i.crossOrigin='anonymous'; i.onload=()=>res(i); i.onerror=rej; i.src=src; });

  function makeTransparent(img){
    const off = document.createElement('canvas');
    off.width = img.width; off.height = img.height;
    const octx = off.getContext('2d', { willReadFrequently: true });
    octx.drawImage(img, 0, 0);
    const d = octx.getImageData(0,0,off.width,off.height);
    const px = d.data;
    for(let i=0;i<px.length;i+=4){
      const r=px[i], g=px[i+1], b=px[i+2];
      // wykryj jasne odcienie „checkerboard”
      if (Math.abs(r-g)<6 && Math.abs(g-b)<6 && r>175 && r<225){
        px[i+3]=0;
      }
    }
    octx.putImageData(d,0,0);
    return off;
  }

  async function loadAssets(){
    const loaded = {};
    for(const [key,cfg] of Object.entries(SPRITE_CFG)){
      const img = await loadImage(cfg.src);
      // Przepuść przez filtr przezroczystości (nie ruszamy teł parallax)
      const isBg = (key==='bgFar'||key==='bgMid');
      const processed = (AUTO_TRANSPARENT && !isBg) ? makeTransparent(img) : img;

      const meta = { img: processed, cols: cfg.cols||1, rows: cfg.rows||1, anim: cfg.anim||null, fps: cfg.fps||8 };
      meta.fw = Math.floor(processed.width  / (meta.cols||1));
      meta.fh = Math.floor(processed.height / (meta.rows||1));
      loaded[key]=meta;
    }
    return loaded;
  }

  class SpriteSheet{
    constructor(meta){ Object.assign(this, meta); }
    draw(ctx, dx, dy, frame, {flip=false, scale=1}={}){
      const sx = (frame % this.cols) * this.fw;
      const sy = Math.floor(frame / this.cols) * this.fh;
      ctx.save();
      ctx.translate(dx, dy);
      if (flip) ctx.scale(-1,1);
      ctx.imageSmoothingEnabled=false;
      ctx.drawImage(this.img, sx, sy, this.fw, this.fh, flip? -this.fw*scale : 0, 0, this.fw*scale, this.fh*scale);
      ctx.restore();
    }
  }

  class Animator{
    constructor(frames, fps){ this.frames=frames||[0]; this.fps=fps||8; this.t=0; }
    step(dt){ this.t += dt*this.fps; }
    frame(){ return this.frames[Math.floor(this.t)%this.frames.length]; }
    reset(){ this.t=0; }
  }

  /* ==========================================================
     2) Prosta scena testowa z animacjami
  ========================================================== */
  const TILE=48, G=2000, JUMP=820, FRICTION=0.86, MAX_VX=320;
  let keys={}, camX=0, paused=false; let A={}, SS={};
  let player, enemies=[], coins=[], powers=[];
  let level;

  function aabb(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }
  class Rect{ constructor(x,y,w,h){ this.x=x; this.y=y; this.w=w; this.h=h; } }

  class Level{
    constructor(plan){
      this.rows=plan.trim().split('\\n'); this.h=this.rows.length; this.w=this.rows[0].length;
      this.pixelW=this.w*TILE; this.pixelH=this.h*TILE;
      this.blocks=[]; this.coins=[]; this.enemies=[]; this.powers=[]; this.flag=null; this.spawn={x:0,y:0};
      for(let y=0;y<this.h;y++) for(let x=0;x<this.w;x++){
        const ch=this.rows[y][x]; const px=x*TILE, py=y*TILE;
        if(ch=='#') this.blocks.push(new Rect(px,py,TILE,TILE));
        if(ch=='?') this.coins.push(new Coin(px+TILE*0.3, py+TILE*0.3));
        if(ch=='E') this.enemies.push(new Enemy(px, py, ['bat','bird','turtle','golem'][Math.floor(Math.random()*4)]));
        if(ch=='F') this.flag=new Rect(px+TILE*0.2, py-TILE*0.5, TILE*0.6, TILE*1.5);
        if(ch=='P') this.spawn={x:px+TILE*0.1, y:py-TILE*0.2};
      }
    }
    query(r){
      const res=[];
      const x0=Math.max(0,Math.floor(r.x/TILE)-1), x1=Math.min(this.w-1,Math.floor((r.x+r.w)/TILE)+1);
      const y0=Math.max(0,Math.floor(r.y/TILE)-1), y1=Math.min(this.h-1,Math.floor((r.y+r.h)/TILE)+1);
      for(let y=y0;y<=y1;y++) for(let x=x0;x<=x1;x++){ if(this.rows[y][x]==='#') res.push({x:x*TILE,y:y*TILE,w:TILE,h:TILE,s:true}); }
      return res;
    }
    drawBackground(){
      const h=canvas.height, w=canvas.width;
      if(A.bgFar){ const speed=0.2; const ox=-(camX*speed)%A.bgFar.img.width; for(let x=ox-w;x<w;x+=A.bgFar.img.width) ctx.drawImage(A.bgFar.img, x, 0, A.bgFar.img.width, h*0.6); }
      if(A.bgMid){ const speed=0.4; const ox=-(camX*speed)%A.bgMid.img.width; for(let x=ox-w;x<w;x+=A.bgMid.img.width) ctx.drawImage(A.bgMid.img, x, h*0.15, A.bgMid.img.width, h*0.7); }
    }
    drawTiles(){
      // Fallback – prostokąty dirt + trawa na górze. Gdy przygotujesz równy grid, podmienimy na rysowanie z SS.tileset.
      ctx.fillStyle='#8b572a';
      for(const b of this.blocks){
        const sx=b.x-camX, sy=b.y; if(sx<-TILE||sx>canvas.width||sy<-TILE||sy>canvas.height) continue;
        ctx.fillRect(sx,sy,TILE,TILE);
        // „trawa” – zielony pasek u góry, gdy nad bloczkiem jest powietrze
        const gx=Math.floor(b.x/TILE), gy=Math.floor(b.y/TILE)-1;
        const above = gy>=0 ? (this.rows[gy][gx]==='#') : false;
        if(!above){ ctx.fillStyle='#2ecc71'; ctx.fillRect(sx, sy, TILE, 10); ctx.fillStyle='#8b572a'; }
      }
    }
  }

  class Camera{ follow(p){ const m=canvas.width*0.35; const cx=camX+canvas.width*0.5; if(p.x-cx>m) camX=p.x-m-canvas.width*0.5; if(cx-p.x>m) camX=p.x+m-canvas.width*0.5; camX=Math.max(0, Math.min(camX, level.pixelW-canvas.width)); } }

  class AnimatorComp{ constructor(sheet, name){ this.sheet=sheet; this.set(name);} set(name){ this.name=name; this.anim=new Animator(sheet.anim && sheet.anim[name] ? sheet.anim[name] : [0], sheet.fps||8);} step(dt){ this.anim.step(dt);} frame(){ return this.anim.frame(); } }

  class Player extends Rect{
    constructor(x,y){ super(x,y, A.hero.fw*2, A.hero.fh*2); this.vx=0; this.vy=0; this.on=false; this.flip=false; this.lives=3; this.score=0;
      this.ctrl=new AnimatorComp(A.hero,'run'); }
    state(name){ this.ctrl.set(name); }
    update(dt){
      const dir=(keys.ArrowRight||keys.KeyD?1:0)-(keys.ArrowLeft||keys.KeyA?1:0);
      if(dir!==0){ this.vx+=dir*2600*dt; this.vx=Math.max(-MAX_VX, Math.min(MAX_VX,this.vx)); this.flip=dir<0; this.state('run'); }
      else { this.vx*=FRICTION; if(Math.abs(this.vx)<4)this.vx=0; this.state('idle'); }
      this.vy+=G*dt;
      if((keys.Space||keys.ArrowUp||keys.KeyW) && this.on){ this.vy=-JUMP; this.on=false; this.state('jump'); }
      // X
      this.x+=this.vx*dt; for(const t of level.query(this)){ if(aabb(this,t)){ if(this.vx>0) this.x=t.x-this.w; else this.x=t.x+t.w; this.vx=0; } }
      // Y
      this.y+=this.vy*dt; this.on=false; for(const t of level.query(this)){ if(aabb(this,t)){ if(this.vy>0){ this.y=t.y-this.h; this.vy=0; this.on=true; } else { this.y=t.y+t.h; this.vy=0; } } }
      for(const c of coins){ if(!c.hit && aabb(this,c)){ c.hit=true; this.score+=10; }}
      for(const e of enemies){ if(!e.dead && aabb(this,e)){ if(this.vy>160){ e.dead=true; this.vy=-JUMP*0.7; this.score+=25; } }}
      if(this.y>level.pixelH+TILE){ this.x=level.spawn.x; this.y=level.spawn.y; }
      this.ctrl.step(dt);
    }
    draw(){ new SpriteSheet(A.hero).draw(ctx, this.x-camX, this.y, this.ctrl.frame(), {flip:this.flip, scale:2}); }
  }

  class Enemy extends Rect{
    constructor(x,y,type){ const meta=A[type]; super(x,y, meta.fw*2, meta.fh*2); this.type=type; this.vx=80*(Math.random()<0.5?-1:1); this.vy=0; this.dead=false; this.flip=false; this.anim=new Animator(A[type].anim.fly||A[type].anim.walk||[0], A[type].fps); }
    update(dt){ if(this.dead) return; this.vy+=G*dt; this.x+=this.vx*dt; this.y+=this.vy*dt; this.flip=this.vx<0;
      for(const t of level.query(this)) if(aabb(this,t)){ if(this.vy>0 && this.y+this.h-t.y<24){ this.y=t.y-this.h; this.vy=0; } else { this.vx*=-1; if(this.vx>0) this.x=t.x-this.w; else this.x=t.x+t.w; } }
      this.anim.step(dt);
    }
    draw(){ new SpriteSheet(A[this.type]).draw(ctx, this.x-camX, this.y, this.anim.frame(), {flip:this.flip, scale:2}); }
  }

  class Coin extends Rect{ constructor(x,y){ super(x,y, A.coin.fw*2, A.coin.fh*2); this.hit=false; this.anim=new Animator(A.coin.anim.spin, A.coin.fps);} update(dt){ this.anim.step(dt);} draw(){ new SpriteSheet(A.coin).draw(ctx, this.x-camX, this.y, this.anim.frame(), {scale:2}); } }

  /* ==========================================================
     3) Start
  ========================================================== */
  const LEVEL0 = `................................................................................
................................................................................
...............................................?...............................
..............................?.................................................
......................###......................................................
.............?.........................E........................................
....P....#########.............###.....................?????.................F..
......................###..............#####..........#########................
.............###............................................................###
.............................................######.....................#######
########################.....############..###########....#####################
########################.....############..###########....#####################`;

  let cam, last=performance.now();

  async function main(){
    A = await loadAssets();
    cam = new (class{ follow(p){ const m=canvas.width*0.35; const cx=camX+canvas.width*0.5; if(p.x-cx>m) camX=p.x-m-canvas.width*0.5; if(cx-p.x>m) camX=p.x+m-canvas.width*0.5; camX=Math.max(0, Math.min(camX, level.pixelW-canvas.width)); } })();
    level = new Level(LEVEL0);
    player = new Player(level.spawn.x, level.spawn.y);
    enemies = level.enemies;
    coins   = level.coins;

    requestAnimationFrame(loop);
  }

  function loop(ts){
    const dt=Math.min(0.033, (ts-last)/1000); last=ts;
    if(!paused){ player.update(dt); for(const e of enemies) e.update(dt); cam.follow(player); }
    // draw
    ctx.clearRect(0,0,canvas.width,canvas.height);
    level.drawBackground();
    level.drawTiles();
    for(const c of coins){ c.update(dt); c.draw(); }
    for(const e of enemies){ e.draw(); }
    player.draw();
    hud.textContent = `Punkty: ${player.score}`;
    requestAnimationFrame(loop);
  }

  // Input
  window.addEventListener('keydown', e=>{ keys[e.code]=true; if(e.code==='KeyP') paused=!paused; });
  window.addEventListener('keyup', e=>{ keys[e.code]=false; });
  resetBtn.addEventListener('click', ()=>{ camX=0; player.x=level.spawn.x; player.y=level.spawn.y; });

  // Go
  main().catch(err=>{ hud.textContent='Błąd ładowania — sprawdź ścieżki /img/*.png'; console.error(err); });
})();
</script>
</body>
</html>
